You are a Java expert and a Git expert, world class.

I will pass you 4 Java classes:
- GitSymple: a class that is the main point of entry, and allows to get GitCommander with GitSymple.getCommander()
- GitCommander: a class that allows to pass Git commands and get output and errors.
- GitWrapper: an interface for Git Wrapper classes 
- GitBranchExample: a simplified example of a wrapper class that does an only update and only a read Git operation.

These classes will be used as a guideline for building a new Wrapper class.
I want you to write following these guidelines a ${0} wrapped class that will have these methods:

${1} 

in order to wrap these Git operations: ${2}

The values of ${0}, ${1} ,and ${2} are at the end of this prompt.

Add a "@author GPT-4" at first Javadoc.
Please include clean & professional Javadoc in the generated class.

Please make sure to use Git commands with the options that don't use a pager or an editor.

Here are the classes:

 * This file is part of SympleGit. 
 * SympleGit: Git in Java for the rest of us.                                     
 * Copyright (C) 2024,  KawanSoft SAS.
 * (http://www.kawansoft.com). All rights reserved.                                
 *                                                                               
 * SympleGit is free software; you can redistribute it and/or                 
 * modify it under the terms of the GNU Lesser General Public                    
 * License as published by the Free Software Foundation; either                  
 * version 2.1 of the License, or (at your option) any later version.            
 *                                                                               
 * SympleGit is distributed in the hope that it will be useful,               
 * but WITHOUT ANY WARRANTY; without even the implied warranty of                
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             
 * Lesser General Public License for more details.                               
 *                                                                               
 * You should have received a copy of the GNU Lesser General Public              
 * License along with this library; if not, write to the Free Software           
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
 * 02110-1301  USA
 *
 * Any modifications to this file must keep this entire header
 * intact.
 */

package com.symplegit.api;

import java.io.File;
import java.util.Objects;

/**
 * SympleGit provides a fluent and simplified interface for configuring and
 * using Git operations. It utilizes a builder pattern for easy configuration
 * and initialization. It is a part of the SympleGit package, which aims to
 * simplify interactions with Git repositories.
 * 
 */
public class SympleGit {

    public static final int DEFAULT_TIMEOUT_SECONDS = 0;
    
    private final File directory;
    private int timeout = DEFAULT_TIMEOUT_SECONDS;

    /**
     * Constructs a new instance of SympleGit with the specified configuration.
     *
     * @param builder The Builder object containing configuration settings.
     */
    private SympleGit(Builder builder) {
        this.directory = builder.directory;
        this.timeout = builder.timeout;
    }

    /**
     * Creates a new Builder instance for configuring SympleGit.
     *
     * @return A new Builder instance.
     */
    public static Builder custom() {
        return new Builder();
    }

    /**
     * Gets the directory associated with this SympleGit instance.
     *
     * @return The directory as a File object.
     */
    public File getDirectory() {
        return directory;
    }

    /**
     * Gets the timeout setting for Git operations.
     *
     * @return The timeout in milliseconds.
     */
    public int getTimeout() {
        return timeout;
    }

    // Additional methods or functionality as needed

    /**
     * Builder class for SympleGit. Provides methods to configure SympleGit instances.
     */
    public static class Builder {

        private File directory;
        private int timeout;

        /**
         * Sets the directory path for the Git repository.
         *
         * @param directoryPath The path to the Git repository directory.
         * @return The Builder instance for chaining.
         */
        public Builder setDirectory(String directoryPath) {
            Objects.requireNonNull(directoryPath, "directoryPath cannot be null");
            this.directory = new File(directoryPath);
            return this;
        }

    public Builder setDirectory(File directoryFile) {
        Objects.requireNonNull(directoryFile, "directoryFile cannot be null");
            this.directory = directoryFile;
            return this;
    }
    
        /**
         * Sets the timeout for Git operations.
         *
         * @param timeout The timeout value in milliseconds.
         * @return The Builder instance for chaining.
         */
        public Builder setTimeout(int timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Builds and returns a SympleGit instance with the current configuration.
         *
         * @return A configured SympleGit instance.
         */
        public SympleGit build() {
            return new SympleGit(this);
        }


    }

    /**
     * Creates a GitCommander instance based on the current SympleGit configuration.
     *
     * @return A new GitCommander instance.
     */
    public GitCommander gitCommander() {
    GitCommander gitCommander = new GitCommander(this);
    return gitCommander;
    }

    @Override
    public String toString() {
    return "SympleGit [directory=" + directory + ", timeout=" + timeout + "]";
    }
    
    
}


 * This file is part of SympleGit. 
 * SympleGit: Git in Java for the rest of us.                                     
 * Copyright (C) 2024,  KawanSoft SAS.
 * (http://www.kawansoft.com). All rights reserved.                                
 *                                                                               
 * SympleGit is free software; you can redistribute it and/or                 
 * modify it under the terms of the GNU Lesser General Public                    
 * License as published by the Free Software Foundation; either                  
 * version 2.1 of the License, or (at your option) any later version.            
 *                                                                               
 * SympleGit is distributed in the hope that it will be useful,               
 * but WITHOUT ANY WARRANTY; without even the implied warranty of                
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             
 * Lesser General Public License for more details.                               
 *                                                                               
 * You should have received a copy of the GNU Lesser General Public              
 * License along with this library; if not, write to the Free Software           
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
 * 02110-1301  USA
 *
 * Any modifications to this file must keep this entire header
 * intact.
 */
package com.symplegit.api;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Date;
import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.apache.commons.io.IOUtils;

import com.symplegit.api.exception.UncheckedTimeoutException;
import com.symplegit.util.ApiDateUtil;
import com.symplegit.util.FrameworkDebug;

/**
 * The GitCommander class is responsible for executing Git commands and handling
 * their outputs. It uses a ProcessBuilder to run Git commands and captures
 * their output and error streams.
 *
 * @author Nicolas de Pomereu
 */
public class GitCommander {

    public static boolean DEBUG = FrameworkDebug.isSet(GitCommander.class);

    private ProcessBuilder builder;
    private Exception exception;
    private int exitCode;

    private File tempErrorFile = null;
    private File tempOutputFile = null;

    private int timeout = 0;

    /**
     * Constructs a GitCommander object with a specified SympleGit instance.
     *
     * @param sympleGit The SympleGit instance to be used for Git command execution.
     * @throws NullPointerException if sympleGit is null.
     */
    GitCommander(SympleGit sympleGit) {
    Objects.requireNonNull(sympleGit, "sympleGit cannot be null!");
    builder = new ProcessBuilder();
    builder.directory(sympleGit.getDirectory());
    this.timeout = sympleGit.getTimeout();
    }


    /**
     * Executes a Git command and handles its output and error streams.
     *
     * @param command The Git command to be executed, split into an array of
     *                strings.
     */
    @SuppressWarnings("unused")
    private void executeGitCommandOld(String... command) {
    Objects.requireNonNull(command, "builder cannot be null!");

    Thread thread = new Thread(() -> {
        executeInThread(command);
    });
    thread.start();

    long begin = System.currentTimeMillis();
        
        debug(" Before while (thread.isAlive())");
        
    while (thread.isAlive()) {
            
        long now = System.currentTimeMillis();
            try {   
                Thread.sleep(100);
            }
            catch (InterruptedException ignore) {
            ignore.printStackTrace();
            }
            
            if ( timeout != 0 &&  (now  - begin > 1000 * timeout)) {
                throw new UncheckedTimeoutException("Timeout after " + timeout + " seconds!");
            };
    }
    
    }
    
    /**
     * Executes a Git command and handles its output and error streams.
     *
     * @param command The Git command to be executed, split into an array of
     *                strings.
     */
    public void executeGitCommand(String... command) {
    
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<String> task = new Callable<String>() {
            @Override
            public String call() throws InterruptedException {
            executeInThread(command);
                return "OK";
            }
        };

        Future<String> future = executor.submit(task);

        try {
            
            long futureTimeout = timeout == 0? Long.MAX_VALUE : timeout;
            
            // Get the result of the asynchronous computation with a timeout of 1 second
            future.get(futureTimeout, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            throw new UncheckedTimeoutException("Timeout after " + timeout + " seconds!");
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown(); // Always remember to shut down the executor service
        }
    }

    /**
     * @param command
     */
    private void executeInThread(String... command) {
    // builder.redirectErrorStream(true);
    Process process = null;

    debug("Git command: " + removeCommas(Arrays.toString(command)));

    try {
        
        builder.command(command); // Correctly set the command
        process = builder.start();

        debug("Before tempErrorFile creation");

        tempErrorFile = File.createTempFile("symplegit-error-" + ApiDateUtil.getDateWithTime() + "-", ".txt");

        try (OutputStream osError = new BufferedOutputStream(new FileOutputStream(tempErrorFile))) {
        IOUtils.copy(new BufferedInputStream(getProcessErrorAsInputStream()), osError);
        }

        debug("After tempErrorFile creation");

        // Optionally, delete the file when the JVM exits
        tempErrorFile.deleteOnExit();

        debug("Before tempOutputFile creation");

        tempOutputFile = File.createTempFile("symplegit-output-" + ApiDateUtil.getDateWithTime() + "-", ".txt");

        try (OutputStream osInput = new BufferedOutputStream(new FileOutputStream(tempOutputFile))) {
        IOUtils.copy(new BufferedInputStream(process.getInputStream()), osInput);
        }

        debug("After tempOutputFile creation");

        // Optionally, delete the file when the JVM exits
        tempOutputFile.deleteOnExit();
        

        debug("waitFor...: " + removeCommas(Arrays.toString(command)));

        exitCode = process.waitFor();
        debug("exitCode: " + exitCode);

        process.destroy();
        process.destroyForcibly();

    } catch (Throwable throwable) {
        if (throwable instanceof Exception) {
        exception = (Exception) throwable;

        } else {
        exception = new Exception(throwable);
        }
    }
    }

    /**
     * Checks if the last executed Git command was successful.
     *
     * @return true if the last Git command executed successfully (exit code 0),
     *         false otherwise.
     */
    public boolean isResponseOk() {
    return exitCode == 0;
    }

    /**
     * Retrieves the exit code of the last executed Git command.
     *
     * @return The exit code of the last Git command execution.
     */
    public int getExitCode() {
    return exitCode;
    }

    /**
     * Gets the standard output of the last executed Git command as a String.
     * <br>
     * It's good practice to test the length of the output as it can be retrieved with {@link #getSize()}.
     *
     * @return The standard output of the last executed Git command.
     * @throws IOException if an I/O error occurs while reading the output.
     */
    public String getProcessOutput() throws IOException {
    return IOUtils.toString(getProcessOutputAsInputStream(), "UTF-8");
    }

    /**
     * Gets the error output of the last executed Git command as a String.
     *
     * @return The error output of the last executed Git command.
     * @throws IOException if an I/O error occurs while reading the error output.
     */
    public String getProcessError() throws IOException {
    return IOUtils.toString(getProcessErrorAsInputStream(), "UTF-8");
    }

    /**
     * Gets the length of the standard output of the last executed Git command. This
     * will allow to decide if the content can be directly retrieved as a String.
     *
     * @return The length of the standard output of the last executed Git command.
     * @throws IOException if an I/O error occurs while reading the output.
     */
    public long getSize() {
    return tempOutputFile.length();
    }

    /**
     * Retrieves the standard output of the last executed Git command as an
     * InputStream.
     *
     * @return An InputStream of the standard output of the last executed Git
     *         command.
     * @throws IOException if the output file does not exist or an I/O error occurs.
     */
    public InputStream getProcessOutputAsInputStream() throws IOException {

    if (tempOutputFile != null && tempOutputFile.exists()) {
        return new BufferedInputStream(new FileInputStream(tempOutputFile));
    }
    return null;
    }

    /**
     * Retrieves the error output of the last executed Git command as an
     * InputStream.
     *
     * @return An InputStream of the error output of the last executed Git command.
     * @throws IOException if the error file does not exist or an I/O error occurs.
     */
    public InputStream getProcessErrorAsInputStream() throws IOException {

    if (tempErrorFile != null && tempErrorFile.exists()) {
        return new BufferedInputStream(new FileInputStream(tempErrorFile));
    }
    return null;

    }

    /**
     * Retrieves the exception that occurred during the last Git command execution,
     * if any.
     *
     * @return The exception thrown during the last Git command execution, or null
     *         if no exception occurred.
     */
    public Exception getException() {
    return exception;
    }

    /**
     * Removes commas from a given string.
     *
     * @param str The string from which commas should be removed.
     * @return The string without commas.
     */
    private String removeCommas(String str) {
    if (str != null && str.contains(",")) {
        str = str.replace(",", "");
    }
    return str;
    }

    /**
     * The delete of the temp files are normally done when the JVM exits with a
     * File.deleteOnExit() call. May be optionally be done to delete immediately the
     * temp files created.
     */
    public void close() {
    if (tempErrorFile != null && tempErrorFile.exists()) {
        tempErrorFile.delete();
    }

    if (tempOutputFile != null && tempOutputFile.exists()) {
        tempOutputFile.delete();
    }
    }

    /**
     * Prints a debug message with the current timestamp if debugging is enabled.
     *
     * @param sMsg The debug message to be printed.
     */
    protected void debug(String sMsg) {
    if (DEBUG) {
        System.out.println(new Date() + " " + sMsg);
    }
    }

}
 * This file is part of SympleGit. 
 * SympleGit: Git in Java for the rest of us.                                     
 * Copyright (C) 2024,  KawanSoft SAS.
 * (http://www.kawansoft.com). All rights reserved.                                
 *                                                                               
 * SympleGit is free software; you can redistribute it and/or                 
 * modify it under the terms of the GNU Lesser General Public                    
 * License as published by the Free Software Foundation; either                  
 * version 2.1 of the License, or (at your option) any later version.            
 *                                                                               
 * SympleGit is distributed in the hope that it will be useful,               
 * but WITHOUT ANY WARRANTY; without even the implied warranty of                
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             
 * Lesser General Public License for more details.                               
 *                                                                               
 * You should have received a copy of the GNU Lesser General Public              
 * License along with this library; if not, write to the Free Software           
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
 * 02110-1301  USA
 *
 * Any modifications to this file must keep this entire header
 * intact.
 */
package com.symplegit.api;

/**
 * The GitWrapper interface defines the essential functionalities that a wrapper
 * class for Git operations should implement. This interface ensures a
 * standardized way of handling responses and errors from Git commands.
 *
 * Implementing classes are expected to provide mechanisms to determine the
 * success of Git operations, retrieve error messages, and obtain any exceptions
 * that may have occurred.
 */
public interface GitWrapper {
    /**
     * Checks whether the last executed Git command completed successfully.
     *
     * @return true if the last Git command executed successfully (e.g., exit code
     *         0), false otherwise.
     */
    public boolean isResponseOk();

    /**
     * Retrieves the error message from the last executed Git command, if any.
     *
     * @return A String containing the error message from the last Git command
     *         execution. Returns null or an empty string if there was no error.
     */
    public String getError();

    /**
     * Gets the exception that was thrown during the last executed Git command, if
     * any.
     *
     * @return An Exception object representing the exception that occurred during
     *         the last Git command execution. Returns null if no exception was
     *         thrown.
     */
    public Exception getException();
}

 * This file is part of SympleGit. 
 * SympleGit: Git in Java for the rest of us.                                     
 * Copyright (C) 2024,  KawanSoft SAS.
 * (http://www.kawansoft.com). All rights reserved.                                
 *                                                                               
 * SympleGit is free software; you can redistribute it and/or                 
 * modify it under the terms of the GNU Lesser General Public                    
 * License as published by the Free Software Foundation; either                  
 * version 2.1 of the License, or (at your option) any later version.            
 *                                                                               
 * SympleGit is distributed in the hope that it will be useful,               
 * but WITHOUT ANY WARRANTY; without even the implied warranty of                
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             
 * Lesser General Public License for more details.                               
 *                                                                               
 * You should have received a copy of the GNU Lesser General Public              
 * License along with this library; if not, write to the Free Software           
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
 * 02110-1301  USA
 *
 * Any modifications to this file must keep this entire header
 * intact.
 */
package com.symplegit.api.facilitator;

import java.io.IOException;

import com.symplegit.api.GitCommander;
import com.symplegit.api.GitWrapper;
import com.symplegit.api.SympleGit;

/**
 * The GitBranchExample class provides functionalities to create a branch and get the active branch name.
 * It implements the GitWrapper interface and uses the GitCommander class to execute Git commands.
 */
public class GitBranchExample implements GitWrapper {

    private GitCommander gitCommander;
    private String errorMessage;
    private Exception exception;

    /**
     * Constructs a GitBranchModifier with a specified SympleGit instance.
     *
     * @param sympleGit The SympleGit instance to be used for Git command execution.
     */
    public GitBranchExample(SympleGit sympleGit) {
        this.gitCommander = sympleGit.gitCommander();
    }

    /**
     * Creates a new branch in the Git repository.
     *
     * @param branchName The name of the branch to be created.
     * @throws IOException If an error occurs during command execution.
     */
    public void createBranch(String branchName) throws IOException {
        executeGitCommandWithErrorHandler("git", "branch", branchName);
    }

    /**
     * Returns the active branch in the Git repository.
     * @return  the active branch in the Git repository.
     * @throws IOException If an error occurs during command execution.
     */
    public String getActiveBranch() throws IOException {
        executeGitCommandWithErrorHandler("git", "rev-parse", "--abbrev-ref", "HEAD");
        
        if (gitCommander.isResponseOk()) {
            String outputString = gitCommander.getProcessOutput();
            if (outputString == null || outputString.isEmpty()) {
                return null;
            }

            return outputString.trim();
        }
        return null;
    }
  
    /**
     * Executes a Git command and handles errors generically.
     *
     * @param command The Git command to be executed.
     * @throws IOException If an error occurs during command execution.
     */
    private void executeGitCommandWithErrorHandler(String... command) throws IOException {
        gitCommander.executeGitCommand(command);

        if (!gitCommander.isResponseOk()) {
            errorMessage = gitCommander.getProcessError();
            exception = gitCommander.getException();
        }
    }
    

    @Override
    public boolean isResponseOk() {
        return gitCommander.isResponseOk();
    }

    @Override
    public String getError() {
        return errorMessage;
    }

    @Override
    public Exception getException() {
        return exception;
    }
}

${0}=GitRepo
${1}=Methods: cloneRepository(repoUrl), initializeRepository(), getRepositoryStatus(), addRemote(name, url), removeRemote(name)
${2}=For repository-wide operations.
